// filepath: c:/Users/tjorb/Documents/Thesis/rtl/UpdateBifurcation.sv
// UpdateBifurcation module
// Implements bifurcation parameter schedule: p(m) = 1 - m/M (conventional)
// or p_i(m) = p_i - (1 - A*x_i^2)*p_i / (M-m) (generalized per-spin)

module UpdateBifurcation #(
    parameter int N = 8,
    parameter int DATA_WIDTH = 32,
    parameter bit PER_SPIN = 1'b0,
    parameter int FRAC_WIDTH = 16
) (
    input  logic clk,
    input  logic rst_n,
    input  logic valid_in,
    
    // Current bifurcation parameters
    input  logic [DATA_WIDTH-1:0] p_global,
    input  logic [N-1:0][DATA_WIDTH-1:0] p_individual,
    
    // Position state for per-spin update
    input  logic [N-1:0][DATA_WIDTH-1:0] x,
    
    // Schedule parameters
    input  logic [31:0] m,      // Current step counter
    input  logic [31:0] M,      // Total steps
    input  logic [DATA_WIDTH-1:0] A,  // Nonlinear control constant
    
    // Updated parameters
    output logic [DATA_WIDTH-1:0] p_global_next,
    output logic [N-1:0][DATA_WIDTH-1:0] p_individual_next,
    output logic valid_out
);

    // =========================================================================
    // Internal signals for intermediate computations
    // =========================================================================
    
    logic [DATA_WIDTH-1:0] m_remaining;  // M - m
    logic [DATA_WIDTH-1:0] m_frac;       // m / M (fixed-point)
    logic [DATA_WIDTH-1:0] p_global_sched;  // 1 - m/M
    
    logic [N-1:0][DATA_WIDTH-1:0] x_squared;  // x_i^2
    logic [N-1:0][DATA_WIDTH-1:0] A_x_sq;     // A * x_i^2
    logic [N-1:0][DATA_WIDTH-1:0] one_minus_A_x_sq;  // 1 - A*x_i^2
    logic [N-1:0][DATA_WIDTH-1:0] scaling_factor;    // (1 - A*x_i^2) / (M-m)
    logic [N-1:0][DATA_WIDTH-1:0] p_decrement;       // p_i * scaling_factor
    
    logic valid_r1, valid_r2, valid_r3;

    // =========================================================================
    // Conventional bifurcation schedule (PER_SPIN=0)
    // p_next = 1 - m/M
    // =========================================================================
    
    always_comb begin
        // m_remaining = M - m (saturate at 0)
        if (m >= M)
            m_remaining = '0;
        else
            m_remaining = M - m;
        
        // Compute m/M in fixed-point (scaled by 2^FRAC_WIDTH)
        // Result is in range [0, 1 << FRAC_WIDTH]
        if (M == 0)
            m_frac = '0;
        else
            m_frac = (m << FRAC_WIDTH) / M;
        
        // p_global_sched = 1.0 - m_frac = (1 << FRAC_WIDTH) - m_frac
        p_global_sched = (1 << FRAC_WIDTH) - m_frac;
        
        // Clamp to [0, 1] in fixed-point
        if (p_global_sched[DATA_WIDTH-1])  // Sign bit indicates underflow
            p_global_sched = '0;
    end
    
    // =========================================================================
    // Per-spin bifurcation schedule (PER_SPIN=1)
    // p_i(m+1) = p_i(m) - (1 - A*x_i^2) * p_i(m) / (M - m)
    // =========================================================================
    
    // Pipeline stage 1: Compute x_squared and intermediate values
    logic [N-1:0][DATA_WIDTH-1:0] x_squared_stage1;
    logic [N-1:0][DATA_WIDTH-1:0] A_x_sq_stage1;
    logic [DATA_WIDTH-1:0] m_remaining_stage1;
    
    generate
        for (genvar i = 0; i < N; i++) begin : gen_x_squared
            // Fixed-point multiply: x[i] * x[i]
            // Result is shifted right by FRAC_WIDTH to maintain fixed-point format
            logic signed [2*DATA_WIDTH-1:0] x_mul;
            always_comb begin
                x_mul = $signed(x[i]) * $signed(x[i]);
                x_squared[i] = x_mul[2*DATA_WIDTH-1:FRAC_WIDTH];
            end
        end
    endgenerate
    
    generate
        for (genvar i = 0; i < N; i++) begin : gen_A_x_sq
            // Fixed-point multiply: A * x_squared[i]
            logic signed [2*DATA_WIDTH-1:0] A_mul;
            always_comb begin
                A_mul = $signed(A) * $signed(x_squared[i]);
                A_x_sq[i] = A_mul[2*DATA_WIDTH-1:FRAC_WIDTH];
            end
        end
    endgenerate
    
    generate
        for (genvar i = 0; i < N; i++) begin : gen_one_minus
            // 1 - A*x_squared[i]
            always_comb begin
                one_minus_A_x_sq[i] = (1 << FRAC_WIDTH) - A_x_sq[i];
                
                // Clamp to [0, ∞)
                if (one_minus_A_x_sq[i][DATA_WIDTH-1])
                    one_minus_A_x_sq[i] = '0;
            end
        end
    endgenerate
    
    generate
        for (genvar i = 0; i < N; i++) begin : gen_scaling
            // scaling_factor = (1 - A*x_i^2) / (M - m)
            logic signed [2*DATA_WIDTH-1:0] scale_mul;
            always_comb begin
                if (m_remaining == 0)
                    scaling_factor[i] = '0;
                else begin
                    scale_mul = $signed(one_minus_A_x_sq[i]) * $signed(p_individual[i]);
                    scaling_factor[i] = scale_mul[2*DATA_WIDTH-1:FRAC_WIDTH] / m_remaining;
                end
            end
        end
    endgenerate
    
    generate
        for (genvar i = 0; i < N; i++) begin : gen_p_update
            // p_individual_next[i] = p_individual[i] - scaling_factor[i]
            always_comb begin
                p_individual_next[i] = p_individual[i] - scaling_factor[i];
                
                // Clamp to [0, ∞)
                if (p_individual_next[i][DATA_WIDTH-1])
                    p_individual_next[i] = '0;
            end
        end
    endgenerate
    
    // =========================================================================
    // Output multiplexing
    // =========================================================================
    
    always_comb begin
        if (PER_SPIN) begin
            // Use per-spin update
            p_global_next = p_individual_next[0];  // Informational only
        end else begin
            // Use conventional schedule: replicate across all spins
            p_global_next = p_global_sched;
            // All individual p's set to same value
            for (int i = 0; i < N; i++)
                p_individual_next[i] = p_global_sched;
        end
    end
    
    // Valid output with pipeline delay
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            valid_r1 <= 1'b0;
            valid_r2 <= 1'b0;
            valid_r3 <= 1'b0;
        end else begin
            valid_r1 <= valid_in;
            valid_r2 <= valid_r1;
            valid_r3 <= valid_r2;
        end
    end
    
    assign valid_out = valid_r3;

endmodule